<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>禁用macos虚拟内存</title>
      <link href="/2019/08/13/%E7%A6%81%E7%94%A8macos%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
      <url>/2019/08/13/%E7%A6%81%E7%94%A8macos%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>启用root用户</p><ol><li>选取苹果菜单 () &gt;“系统偏好设置”，然后点按“用户与群组”（或“帐户”）。</li><li>点按 锁形图标，然后输入管理员名称和密码。</li><li>点按“登录选项”。</li><li>点按“加入”（或“编辑”）。</li><li>点按“打开目录实用工具”。</li><li>点按“目录实用工具”窗口中的 锁形图标，然后输入管理员名称和密码。</li><li>从“目录实用工具”的菜单栏中：<ul><li>选取“编辑”&gt;“启用 Root 用户”，然后输入要用于 root 用户的密码。</li><li>或者选取“编辑”&gt;“停用 Root 用户”。</li></ul></li></ol><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>Mac OS X 在操作系统层面对root账户进行了限制，需要解除限制。</p><ol><li>重启电脑，按Command + R 进入恢复模式。</li><li>单机Utilities选择Terminal终端，csrutil status查看是否启用系统完整性保护。</li><li>csrutil disable # 禁用</li><li>csrutil enable # 启用</li></ol><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>进入/private/var/vm文件夹，建立同名文件夹，让系统不能创建同名文件。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> su root</span><br><span class="line"><span class="meta">$</span> cd /private/var/vm</span><br><span class="line"><span class="meta">$</span> sudo mkdir swapfile0 swapfile1 swapfile2 swapfile3 swapfile4 swapfile5</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读Go源码-log/log.go</title>
      <link href="/2019/08/10/%E8%AF%BBGo%E6%BA%90%E7%A0%81-log-log-go/"/>
      <url>/2019/08/10/%E8%AF%BBGo%E6%BA%90%E7%A0%81-log-log-go/</url>
      
        <content type="html"><![CDATA[<h2 id="雨点"><a href="#雨点" class="headerlink" title="雨点"></a>雨点</h2><ul><li>iota 常量计数器</li><li>sync.Mutex 互斥锁</li><li>单引号与双引号的区别</li><li>位运算</li></ul><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>定义常量<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// the date in the local time zone: 2009/01/23</span></span><br><span class="line">Ltime                         <span class="comment">// the time in the local time zone: 01:23:23</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// microsecond resolution: 01:23:23.123123.  assumes Ltime.</span></span><br><span class="line">Llongfile                     <span class="comment">// full file name and line number: /a/b/c/d.go:23</span></span><br><span class="line">Lshortfile                    <span class="comment">// final file name element and line number: d.go:23. overrides Llongfile</span></span><br><span class="line">LUTC                          <span class="comment">// if Ldate or Ltime is set, use UTC rather than the local time zone</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// initial values for the standard logger</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>定义结构体<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123;</span><br><span class="line">mu     sync.Mutex <span class="comment">// ensures atomic writes; protects the following fields</span></span><br><span class="line">prefix <span class="keyword">string</span>     <span class="comment">// prefix to write at beginning of each line</span></span><br><span class="line">flag   <span class="keyword">int</span>        <span class="comment">// properties</span></span><br><span class="line">out    io.Writer  <span class="comment">// destination for output</span></span><br><span class="line">buf    []<span class="keyword">byte</span>     <span class="comment">// for accumulating text to write</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造单例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(out io.Writer, prefix <span class="keyword">string</span>, flag <span class="keyword">int</span>)</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Logger&#123;out: out, prefix: prefix, flag: flag&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> std = New(os.Stderr, <span class="string">""</span>, LstdFlags)</span><br></pre></td></tr></table></figure></p><p>日志输出<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Println</span><span class="params">(v ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123; l.Output(<span class="number">2</span>, fmt.Sprintln(v...)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">Output</span><span class="params">(calldepth <span class="keyword">int</span>, s <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">now := time.Now() <span class="comment">// get this early.</span></span><br><span class="line"><span class="keyword">var</span> file <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> line <span class="keyword">int</span></span><br><span class="line">l.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> l.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;(Lshortfile|Llongfile) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Release lock while getting caller info - it's expensive.</span></span><br><span class="line">l.mu.Unlock()</span><br><span class="line"><span class="keyword">var</span> ok <span class="keyword">bool</span></span><br><span class="line">_, file, line, ok = runtime.Caller(calldepth)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">file = <span class="string">"???"</span></span><br><span class="line">line = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">l.mu.Lock()</span><br><span class="line">&#125;</span><br><span class="line">l.buf = l.buf[:<span class="number">0</span>]</span><br><span class="line">l.formatHeader(&amp;l.buf, now, file, line)</span><br><span class="line">l.buf = <span class="built_in">append</span>(l.buf, s...)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> || s[<span class="built_in">len</span>(s)<span class="number">-1</span>] != <span class="string">'\n'</span> &#123;</span><br><span class="line">l.buf = <span class="built_in">append</span>(l.buf, <span class="string">'\n'</span>)</span><br><span class="line">&#125;</span><br><span class="line">_, err := l.out.Write(l.buf)</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造日志头部<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Logger)</span> <span class="title">formatHeader</span><span class="params">(buf *[]<span class="keyword">byte</span>, t time.Time, file <span class="keyword">string</span>, line <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, l.prefix...)</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;(Ldate|Ltime|Lmicroseconds) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;LUTC != <span class="number">0</span> &#123;</span><br><span class="line">t = t.UTC()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;Ldate != <span class="number">0</span> &#123;</span><br><span class="line">year, month, day := t.Date()</span><br><span class="line">itoa(buf, year, <span class="number">4</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">'/'</span>)</span><br><span class="line">itoa(buf, <span class="keyword">int</span>(month), <span class="number">2</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">'/'</span>)</span><br><span class="line">itoa(buf, day, <span class="number">2</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;(Ltime|Lmicroseconds) != <span class="number">0</span> &#123;</span><br><span class="line">hour, min, sec := t.Clock()</span><br><span class="line">itoa(buf, hour, <span class="number">2</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">':'</span>)</span><br><span class="line">itoa(buf, min, <span class="number">2</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">':'</span>)</span><br><span class="line">itoa(buf, sec, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;Lmicroseconds != <span class="number">0</span> &#123;</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">'.'</span>)</span><br><span class="line">itoa(buf, t.Nanosecond()/<span class="number">1e3</span>, <span class="number">6</span>)</span><br><span class="line">&#125;</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;(Lshortfile|Llongfile) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> l.flag&amp;Lshortfile != <span class="number">0</span> &#123;</span><br><span class="line">short := file</span><br><span class="line"><span class="keyword">for</span> i := <span class="built_in">len</span>(file) - <span class="number">1</span>; i &gt; <span class="number">0</span>; i-- &#123;</span><br><span class="line"><span class="keyword">if</span> file[i] == <span class="string">'/'</span> &#123;</span><br><span class="line">short = file[i+<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">file = short</span><br><span class="line">&#125;</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, file...)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">':'</span>)</span><br><span class="line">itoa(buf, line, <span class="number">-1</span>)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, <span class="string">": "</span>...)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数字追加到字符串后<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itoa</span><span class="params">(buf *[]<span class="keyword">byte</span>, i <span class="keyword">int</span>, wid <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// Assemble decimal in reverse order.</span></span><br><span class="line"><span class="keyword">var</span> b [<span class="number">20</span>]<span class="keyword">byte</span></span><br><span class="line">bp := <span class="built_in">len</span>(b) - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &gt;= <span class="number">10</span> || wid &gt; <span class="number">1</span> &#123;</span><br><span class="line">wid--</span><br><span class="line">q := i / <span class="number">10</span></span><br><span class="line">b[bp] = <span class="keyword">byte</span>(<span class="string">'0'</span> + i - q*<span class="number">10</span>)</span><br><span class="line">bp--</span><br><span class="line">i = q</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// i &lt; 10</span></span><br><span class="line">b[bp] = <span class="keyword">byte</span>(<span class="string">'0'</span> + i)</span><br><span class="line">*buf = <span class="built_in">append</span>(*buf, b[bp:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="iota-常量计数器"><a href="#iota-常量计数器" class="headerlink" title="iota 常量计数器"></a>iota 常量计数器</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每遇到一个const关键字，iota就会重置</span></span><br><span class="line"><span class="comment">// 如果中断iota，必须显式恢复！！！</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Ldate         = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span>     <span class="comment">// 1 &lt;&lt; 01</span></span><br><span class="line">Ltime                         <span class="comment">// 1 &lt;&lt; 12</span></span><br><span class="line">Lmicroseconds                 <span class="comment">// 1 &lt;&lt; 24</span></span><br><span class="line">Llongfile                     <span class="comment">// 1 &lt;&lt; 38</span></span><br><span class="line">Lshortfile                    <span class="comment">// 1 &lt;&lt; 416</span></span><br><span class="line">LUTC                          <span class="comment">// 1 &lt;&lt; 532</span></span><br><span class="line">LstdFlags     = Ldate | Ltime <span class="comment">// 1 | 23</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="sync-Mutex-互斥锁"><a href="#sync-Mutex-互斥锁" class="headerlink" title="sync.Mutex 互斥锁"></a>sync.Mutex 互斥锁</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当Lock()时，资源会进入锁定状态。</span></span><br><span class="line"><span class="comment">// 当前只能有一个协程执行，只有Unlock()后限制才解开。 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;</span><br><span class="line">m.Lock()</span><br><span class="line">x = x + <span class="number">1</span></span><br><span class="line">m.Unlock()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">w.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> increment(&amp;w, &amp;m)</span><br><span class="line">&#125;</span><br><span class="line">w.Wait()</span><br><span class="line">fmt.Println(<span class="string">"final value of x"</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单引号与双引号的区别"><a href="#单引号与双引号的区别" class="headerlink" title="单引号与双引号的区别"></a>单引号与双引号的区别</h2><p>单引号：rune类型<br>双引号：字符串类型</p><blockquote><p>rune 类型是int32的别名类型，可表示Unicode字符。</p></blockquote><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>|：或运算<br>&amp;：与运算<br>&lt;&lt; 左移<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> | <span class="number">2</span>  ==&gt; <span class="number">0001</span> | <span class="number">0010</span> ==&gt; <span class="number">0011</span> ==&gt; <span class="number">3</span></span><br><span class="line"><span class="number">1</span> &amp; <span class="number">3</span>  ==&gt; <span class="number">0001</span> &amp; <span class="number">0011</span> ==&gt; <span class="number">0001</span> ==&gt; <span class="number">1</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">2</span> ==&gt; <span class="number">0001</span> &lt;&lt; <span class="number">2</span> ==&gt; <span class="number">0100</span> ==&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 某字段分组后，其他字段以逗号隔开</title>
      <link href="/2019/07/24/MySQL-%E6%9F%90%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%E5%90%8E%EF%BC%8C%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E4%BB%A5%E9%80%97%E5%8F%B7%E9%9A%94%E5%BC%80/"/>
      <url>/2019/07/24/MySQL-%E6%9F%90%E5%AD%97%E6%AE%B5%E5%88%86%E7%BB%84%E5%90%8E%EF%BC%8C%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E4%BB%A5%E9%80%97%E5%8F%B7%E9%9A%94%E5%BC%80/</url>
      
        <content type="html"><![CDATA[<h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE student (</span><br><span class="line">age INT,</span><br><span class="line">name VARCHAR(20)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="造数据"><a href="#造数据" class="headerlink" title="造数据"></a>造数据</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO </span><br><span class="line">student(age, name)</span><br><span class="line">VALUES</span><br><span class="line">(15, &apos;陈x&apos;),</span><br><span class="line">(16, &apos;冯xx&apos;),</span><br><span class="line">(15, &apos;郑xx&apos;),</span><br><span class="line">(16, &apos;王xx&apos;),</span><br><span class="line">(15, &apos;刘xx&apos;)</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">age</th><th style="text-align:center">name</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">陈x</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">冯xx</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">郑xx</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">王xx</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">刘xx</td></tr></tbody></table><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">age, GROUP_CONCAT(name SEPARATOR &apos;,&apos;) AS names </span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">GROUP BY</span><br><span class="line">age</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:center">age</th><th style="text-align:center">names</th></tr></thead><tbody><tr><td style="text-align:center">15</td><td style="text-align:center">陈x,郑xx,刘xx</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">冯xx,王xx</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go语言-Map排序</title>
      <link href="/2019/07/22/Go%E8%AF%AD%E8%A8%80-Map%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/07/22/Go%E8%AF%AD%E8%A8%80-Map%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>由于map输出是无序的，我希望map输出有序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">mp[<span class="string">"1"</span>] = <span class="number">1</span></span><br><span class="line">mp[<span class="string">"5"</span>] = <span class="number">45</span></span><br><span class="line">mp[<span class="string">"6"</span>] = <span class="number">3</span></span><br><span class="line">mp[<span class="string">"4"</span>] = <span class="number">22</span></span><br><span class="line">mp[<span class="string">"2"</span>] = <span class="number">5</span></span><br><span class="line">mp[<span class="string">"3"</span>] = <span class="number">16</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"---------------正序----------------"</span>)</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> sortMapKey(mp) &#123;</span><br><span class="line">fmt.Println(<span class="string">"key:"</span>, v, <span class="string">"    value:"</span>, mp[v])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"---------------倒序----------------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> reverseMapKey(mp) &#123;</span><br><span class="line">fmt.Println(<span class="string">"key:"</span>, v, <span class="string">"    value:"</span>, mp[v])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 根据 key 正序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sortMapKey</span><span class="params">(mp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">strArray := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> mp &#123;</span><br><span class="line">strArray = <span class="built_in">append</span>(strArray, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(strArray)</span><br><span class="line"><span class="keyword">return</span> strArray</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 根据 key 倒序排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseMapKey</span><span class="params">(mp <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">strArray := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> mp &#123;</span><br><span class="line">strArray = <span class="built_in">append</span>(strArray, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Sort(sort.Reverse(sort.StringSlice(strArray)))</span><br><span class="line"><span class="keyword">return</span> strArray</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---------------正序----------------</span><br><span class="line">key: 1     value: 1</span><br><span class="line">key: 2     value: 5</span><br><span class="line">key: 3     value: 16</span><br><span class="line">key: 4     value: 22</span><br><span class="line">key: 5     value: 45</span><br><span class="line">key: 6     value: 3</span><br><span class="line">---------------倒序----------------</span><br><span class="line">key: 6     value: 3</span><br><span class="line">key: 5     value: 45</span><br><span class="line">key: 4     value: 22</span><br><span class="line">key: 3     value: 16</span><br><span class="line">key: 2     value: 5</span><br><span class="line">key: 1     value: 1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim_1</title>
      <link href="/2019/06/04/vim-1/"/>
      <url>/2019/06/04/vim-1/</url>
      
        <content type="html"><![CDATA[<ol><li>保存编辑结果<br><code>命令行模式输入 ZZ，等同于ex命令 :wq</code></li><li>消除所有编辑结果<br><code>ex命令 :e!</code></li><li>消除所有编辑结果，并离开vim<br><code>ex命令 :q!</code></li><li>vim执行unix命令（三种方式）<br><code>ex命令 :!xxx 如 :!df</code><br><code>ex命令 :sh，CTRL-D或输入exit回到vim</code><br><code>CTRL-Z暂停vim，输入fg回到vim</code></li><li>命令行模式移动光标<br><code>h 左 l 右 k 上 j 下</code><br><code>0 移到行开头 $ 移到行结尾</code><br><code>w 按照文本块前进 b 后退 注 标点符号也算一个单词</code><br><code>W 按照文本块前进 B 后退 注 标点符号不算一个单词</code><br><code>G 跳转行 如 5G跳转第五行，G跳到行尾</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定制go get的包路径</title>
      <link href="/2019/04/29/%E5%AE%9A%E5%88%B6go-get%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/04/29/%E5%AE%9A%E5%88%B6go-get%E7%9A%84%E5%8C%85%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>当工程使用gitlab作为代码管理工具，各个工程会按照群组分类，但代码中引入包名的时候却不希望路径带有群组，又或者gitlab域名带有端口号。这样go get下来的路径会不美观。如：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 项目路径为</span><br><span class="line">https://xxx.xxx.com:90/Gxxx/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Go get后go/src下的目录结构为</span><br><span class="line">xxx.xxx.com:90/Gxxx/xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 项目中却希望以如下方式引入包</span><br><span class="line">xxx.xxx.com/xxx</span><br></pre></td></tr></table></figure><blockquote><p>⚠️注意：</p><p>若想要go get gitlab上的项目，需要在命令行执行如下命令。<br><code>git config --global url.&quot;git@xxx.xxx.com:&quot;.insteadOf &quot;https://xxx.xxx.com:90/&quot;</code><br>在~/.gitconfig文件中查看是否配置成功。</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用反向代理将xxx.xxx.com:90/Gxxx映射到xxx.xxx.com上，本地只要go get xxx.xxx.com/xxx会去真实的路径上拉取代码。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ol><li><p>前置条件</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 阿里云服务器一台（centos）</span><br><span class="line">2. 服务器配置好go环境</span><br><span class="line">3. 执行go get github.com/denyu95/govanityurls</span><br></pre></td></tr></table></figure></li><li><p>路径映射</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 路径映射由govanityurls项目完成，启动govanityurls即可。（监听8080端口）</span><br><span class="line">1. 在root目录下创建govanityurls目录。</span><br><span class="line">2. 放入vanity.yaml配置文件。</span><br><span class="line">3. 使用Supervisord守护进程的工具启动govanityurls。</span><br></pre></td></tr></table></figure></li><li><p>代理转发</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span> 配置nginx代理转发 80端口-》8080端口</span><br><span class="line">1. https 需要申请证书</span><br><span class="line">2. 得到 xxx.xxx.pem 和 xxx.xxx.key 放到 /etc/nginx/ssl 目录下</span><br><span class="line">3. 启动nginx</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><p> vanity.yaml</p> <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/gowechat:</span></span><br><span class="line"><span class="attr">        repo:</span> <span class="attr">https://github.com/xxx/gowechat</span></span><br><span class="line"><span class="string">/subscriptionserver:</span></span><br><span class="line"><span class="attr">        repo:</span> <span class="attr">https://xxx.xxx.com:90/xxx/subscriptionserver</span></span><br></pre></td></tr></table></figure><p> supervisord.d/govanityurls.ini</p> <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[program:govanityurls]</span><br><span class="line">directory = /root/govanityurls</span><br><span class="line">command = /root/go/bin/govanityurls -host xxx.xxx.com</span><br><span class="line">autostart = true</span><br><span class="line">startsecs = 5</span><br><span class="line">autorestart = true</span><br><span class="line">startretries = 3</span><br><span class="line">user = root</span><br><span class="line">redirect_stderr = true</span><br><span class="line">stdout_logfile_maxbytes = 20MB</span><br><span class="line">stdout_logfile_backups = 20</span><br><span class="line">stopasgroup=false</span><br><span class="line">killasgroup=false</span><br><span class="line">stdout_logfile = /root/log/go.log</span><br></pre></td></tr></table></figure><p> nginx.conf</p> <figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span> xxx.xxx.com;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span>           /etc/nginx/ssl/xxx.xxx.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>       /etc/nginx/ssl/xxx.xxx.key;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">                <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">               <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">                <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Connection <span class="string">"upgrade"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>团队需要维护vanity.yaml配置文件，需要不断补充项目映射关系。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu开机不启动图形界面</title>
      <link href="/2019/04/25/ubuntu%E5%BC%80%E6%9C%BA%E4%B8%8D%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/"/>
      <url>/2019/04/25/ubuntu%E5%BC%80%E6%9C%BA%E4%B8%8D%E5%90%AF%E5%8A%A8%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<ol><li><p>关闭用户图形界面，使用tty(终端设备的统称)登陆。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li><li><p>开启用户图形界面。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>配置命令行翻墙开关</title>
      <link href="/2019/04/25/%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E5%A2%99%E5%BC%80%E5%85%B3/"/>
      <url>/2019/04/25/%E9%85%8D%E7%BD%AE%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%BF%BB%E5%A2%99%E5%BC%80%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>只针对mac用户的配置。<br>由于控制台窗口无法翻墙，在.bash_profile文件中配置http_proxy代理到1087。不用的时候要注释掉，使用起来着实麻烦。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><ol><li>本地安装Shadowsocks</li><li>拥有翻墙账号</li></ol><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加如下命令</span><br><span class="line">export http_proxy=</span><br><span class="line">export https_proxy=</span><br><span class="line">alias on="sed -i '' 's/_proxy=$/_proxy=http:\/\/127.0.0.1:1087/g' ~/.bash_profile &amp;&amp; source ~/.bash_profile"</span><br><span class="line">alias off="sed -i '' 's/_proxy=http:\/\/127.0.0.1:1087$/_proxy=/g' ~/.bash_profile &amp;&amp; source ~/.bash_profile"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开启命令行翻墙</span><br><span class="line"><span class="meta">$</span> on</span><br><span class="line"><span class="meta">#</span> 关闭命令行翻墙</span><br><span class="line"><span class="meta">$</span> off</span><br></pre></td></tr></table></figure><blockquote><p>关于sed的使用</p><p>错误写法：sed -i ‘s/a/b/g’ test.txt</p><p>原因：mac强制要求备份，否则报错。当然可以不使用其他备份名字，只是用’’，就可以只保留一份。</p><p>正确写法：sed -i ‘.bak’ ‘s/a/b/g’ test.txt</p><p>上面语句的意思是，将test.txt文本中所有的a替换成b。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 懒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-并发</title>
      <link href="/2019/04/04/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%B9%B6%E5%8F%91/"/>
      <url>/2019/04/04/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%B9%B6%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>进程是个容器，其存放内存地址空间、文件和设备的句柄、线程等等。线程是个执行空间，这个空间会被操作系统调度来执行代码。</p><p><img src="进程与线程.jpg" alt="进程与线程"></p><h2 id="Goroutine运作方式"><a href="#Goroutine运作方式" class="headerlink" title="Goroutine运作方式"></a>Goroutine运作方式</h2><p>运行一个goroutine：</p><ol><li>将这个goroutine放在调度器全局的运行队列上。</li><li>调度器将队列中的goroutine分配给一个逻辑处理器，逻辑处理器都绑定在单个线程上。</li><li>goroutine会被放到逻辑处理器的本地运行队列中，等待执行。</li></ol><p>goroutine遇到阻塞：</p><ol><li>线程阻塞，等待操作系统返回。线程和正在运行的goroutine会从逻辑处理器上分离。</li><li>调度器会创建一个新线程，并将其绑定到之前的逻辑处理器上。</li><li>调度器会从本地运行队列选择goroutine继续执行。</li></ol><p><img src="Goroutine运作方式.png" alt="Goroutine运作方式"></p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>并行是让不同的代码片段同时在不同的物理处理器上执行。</p><p>并发是同时管理很多事情，这些事情可能做一半就被暂停去做别的事情了。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring常用配置</title>
      <link href="/2019/03/25/Spring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/25/Spring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Bean的Scope"><a href="#Bean的Scope" class="headerlink" title="Bean的Scope"></a>Bean的Scope</h2><p>简单讲解两个：</p><ol><li>Singleton：共享一个实例</li><li>Prototype：每次调用新建一个实例</li></ol><p>Singleton</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Scope默认为Singleton，所以不需要加@Scope(“singleton”)。</p></blockquote><p>Prototype</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeService</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"需要扫描的包"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeConfig</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(ScopeConfig.class);</span><br><span class="line"></span><br><span class="line">SingletonService s1 = annotationConfigApplicationContext.getBean(SingletonService.class);</span><br><span class="line"></span><br><span class="line">SingletonService s2 = annotationConfigApplicationContext.getBean(SingletonService.class);</span><br><span class="line"></span><br><span class="line">PrototypeService p1 = annotationConfigApplicationContext.getBean(PrototypeService.class);</span><br><span class="line"></span><br><span class="line">PrototypeService p2 = annotationConfigApplicationContext.getBean(PrototypeService.class);</span><br><span class="line"></span><br><span class="line">System.out.println(s1.equals(s2));</span><br><span class="line">System.out.println(p1.equals(p2));</span><br></pre></td></tr></table></figure><blockquote><p>结果：</p><ol><li>s1与s2相等</li><li>p1与p2不相等</li></ol></blockquote><h2 id="资源调用"><a href="#资源调用" class="headerlink" title="资源调用"></a>资源调用</h2><p>@Value中的参数使用EL表达式，支持如下几种情况：</p><ol><li>注入普通字符</li><li>注入操作系统属性</li><li>注入表达式运算结果</li><li>注入其他Bean的属性</li><li>注入文件内容</li><li>注入网址内容</li><li>注入属性文件</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test.properties</span><br><span class="line"></span><br><span class="line">book.name=spring</span><br><span class="line">book.author=denyu</span><br><span class="line">---</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"+++"</span>)</span><br><span class="line">    <span class="keyword">private</span> String another;</span><br><span class="line">    getAnother()...;</span><br><span class="line">    setAnother()...;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"需要扫描的包"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:xxx/xxx/test.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"~~~"</span>)</span><br><span class="line">    <span class="keyword">private</span> String normal;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;systemProperties['os.name']&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;T(java.lang.Math).random() * 100.0&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String randomNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;demoService.another&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String fromAnother;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"calsspath:xxx/xxx/test.txt"</span>)</span><br><span class="line">    <span class="keyword">private</span> Resource testFile;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">    <span class="keyword">private</span> Resource testUrl;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;book.name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PropertySourcesPlaceholderConfigurer <span class="title">propertyConfigure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertySourcesPlaceholderConfigurer();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    environment.getProperty(<span class="string">"book.author"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用@PropertySource指定文件地址，若用@Value注入，则需要配置一个PropertySourcesPlaceholderConfigurer的Bean。</p><p>注入Properties还可以从Environment中获得，详见代码的book.author的获取。</p></blockquote><h2 id="Bean的初始化和销毁"><a href="#Bean的初始化和销毁" class="headerlink" title="Bean的初始化和销毁"></a>Bean的初始化和销毁</h2><ol><li>Java配置方式</li><li>JSR-250注解方式</li></ol><p>Java配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWayService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSR250注解</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JSR250WayService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pom.xml文件</span></span><br><span class="line">&lt;!--增加JSR250支持--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;javax.annotation&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;jsr250-api&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"..."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(initMethod=<span class="string">"init"</span>, destroyMethod=<span class="string">"destroy"</span>)</span><br><span class="line">    <span class="function">BeanWayService <span class="title">beanWayService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanWayService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JSR250WayService jsr250WayService &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JSR250WayService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java配置与JSR-250注解方式的效果是一样的。</p><p>init在类被构造后执行，destroy在类被销毁前执行。</p></blockquote><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>可根据设置profile区分环境</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoBean</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    getContent()...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">devDemoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from dev"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoBean <span class="title">prodDemoBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoBean(<span class="string">"from prod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line"></span><br><span class="line">context.getEnvironment().setActiveProfiles(<span class="string">"prod"</span>);</span><br><span class="line">context.register(ProfileConfig.class);</span><br><span class="line">context.refresh();</span><br><span class="line"></span><br><span class="line">DemoBean demoBean = context.getBean(DemoBean.class);</span><br><span class="line">System.out.println(demoBean.getContent());</span><br><span class="line">annotationConfigApplicationContext.close();</span><br></pre></td></tr></table></figure><blockquote><ol><li>先将活动的Profile设置为prod</li><li>注册Bean的配置类</li><li>刷新容器</li></ol></blockquote><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ol><li>自定义事件，继承自ApplicationEvent。</li><li>定义事件监听，实现ApplicationListener。</li><li>使用容器发布事件。</li></ol><p>自定义事件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoEvent</span><span class="params">(Object source, String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义事件监听</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">DemoEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(DemoEvent demoEvent)</span> </span>&#123;</span><br><span class="line">        String msg = demoEvent.getMsg();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"我（Listener）接收到了（Publisher）发布的消息："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件发布类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPublisher</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        applicationContext.publishEvent(<span class="keyword">new</span> DemoEvent(<span class="keyword">this</span>, msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">省略</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">demoPublisher.publish(<span class="string">"hello ..."</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux处理僵尸进程</title>
      <link href="/2019/03/22/Linux%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>/2019/03/22/Linux%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="僵尸进程产生的原因"><a href="#僵尸进程产生的原因" class="headerlink" title="僵尸进程产生的原因"></a>僵尸进程产生的原因</h2><p>当一个进程被终止，其父进程和内核还是需要知道进程的有些信息，如进程的ID号、进程的退出状态、进程运行的CPU时间等。进程在终止时回收内核分配给它的内存、关闭它打开的所有文件等，但还是会保留极少信息，以供父进程使用。父进程调用 wait / waitid 获取子进程信息以释放保留的那段信息。 </p><p>原因</p><ol><li>子进程终止后向父进程发出SIGCHLD信号，父进程默认忽略了它。</li><li>父进程没有调用wait()或waitid()函数来等待子进程结束。</li></ol><h2 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h2><p>僵尸进程虽然占用系统资源少，但是如果数量多的话，一样会严重影响到服务器性能。</p><h2 id="僵尸进程如何kill"><a href="#僵尸进程如何kill" class="headerlink" title="僵尸进程如何kill"></a>僵尸进程如何kill</h2><p>查看僵尸进程<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux |grep Z</span><br><span class="line"><span class="meta">#</span> STAT为Z说明是僵尸进程</span><br></pre></td></tr></table></figure></p><p>查看僵尸进程的数量<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top|head -n 2</span><br><span class="line"><span class="meta">#</span> zombie的数量就是僵尸进程的数量</span><br></pre></td></tr></table></figure></p><h3 id="普通僵尸进程"><a href="#普通僵尸进程" class="headerlink" title="普通僵尸进程"></a>普通僵尸进程</h3><p>手动杀死父进程后，由系统init进程回收。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep PID</span><br><span class="line">kill -9 PPID</span><br><span class="line"><span class="meta">#</span> 此处PID为僵尸进程的，通过ps命令查询可得到PPID。</span><br><span class="line"><span class="meta">#</span> 杀死父进程的PPID</span><br></pre></td></tr></table></figure></p><h3 id="PPID为1的僵尸进程"><a href="#PPID为1的僵尸进程" class="headerlink" title="PPID为1的僵尸进程"></a>PPID为1的僵尸进程</h3><p>暂时没有好的解决方式，需要重启主机。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 疑难杂症 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMeter压测实战</title>
      <link href="/2019/03/22/JMeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E6%88%98/"/>
      <url>/2019/03/22/JMeter%E5%8E%8B%E6%B5%8B%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 压测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMeter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令-持续更新</title>
      <link href="/2019/03/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2019/03/21/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="查看当前文件夹全路径"><a href="#查看当前文件夹全路径" class="headerlink" title="查看当前文件夹全路径"></a>查看当前文件夹全路径</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h4 id="查看文件目录下的文件列表"><a href="#查看文件目录下的文件列表" class="headerlink" title="查看文件目录下的文件列表"></a>查看文件目录下的文件列表</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><h4 id="查看文件目录下的文件列表-详细信息"><a href="#查看文件目录下的文件列表-详细信息" class="headerlink" title="查看文件目录下的文件列表(详细信息)"></a>查看文件目录下的文件列表(详细信息)</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -alF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 环境变量中配置 alias ll='ls -alF'</span><br><span class="line"><span class="meta">#</span> 即可使用 ll 替代 ls -alF</span><br></pre></td></tr></table></figure><h4 id="进程名-lt-或启动脚本名-gt-查UID-PID-PPID"><a href="#进程名-lt-或启动脚本名-gt-查UID-PID-PPID" class="headerlink" title="进程名&lt;或启动脚本名&gt;查UID PID PPID"></a>进程名&lt;或启动脚本名&gt;查UID PID PPID</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep xxx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> xxx 代表启动的程序名或脚本名</span><br><span class="line"><span class="meta">#</span> ps -ef 显示所有命令，连带命令行以及UID PID PPID信息</span><br><span class="line"><span class="meta">#</span> grep 过滤文本</span><br></pre></td></tr></table></figure><h4 id="PID反查端口-端口反查PID"><a href="#PID反查端口-端口反查PID" class="headerlink" title="PID反查端口,端口反查PID"></a>PID反查端口,端口反查PID</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 用PID反查端口</span><br><span class="line">netstat -antup|grep 8178</span><br><span class="line">// 用端口反查PID</span><br><span class="line">netstat -antup|grep 8761</span><br><span class="line">//输出tcp600:::8761:::*LISTEN8178/java</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-类型系统</title>
      <link href="/2019/03/15/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/03/15/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="用户定义的类型"><a href="#用户定义的类型" class="headerlink" title="用户定义的类型"></a>用户定义的类型</h2><p>声明结构类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    level<span class="keyword">int</span></span><br><span class="line">    personuser</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    age<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明变量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="keyword">var</span> mike user</span><br><span class="line"><span class="comment">// 第二种方式</span></span><br><span class="line">mike := user&#123;</span><br><span class="line">    name:<span class="string">"Mike"</span>,</span><br><span class="line">    age:<span class="number">24</span>,</span><br><span class="line">&#125;</span><br><span class="line">root := admin&#123;</span><br><span class="line">    person: user&#123;</span><br><span class="line">        name:<span class="string">"Mike"</span>,</span><br><span class="line">        age:<span class="number">24</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    level:<span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第三种方式</span></span><br><span class="line">mike := user&#123;<span class="string">"Mike"</span>, <span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure><p>基于内置类型声明一个新类型。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然int64是Duration的基础类型，但是int64与Duration是不同的类型。</p></blockquote><p>不同类型的变量赋值会报错。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">type</span> Duration <span class="keyword">int64</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> dur Duration</span><br><span class="line">    dur = <span class="keyword">int64</span>(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>不管方法的接受者为值还是指针，都可以可以使用值或指针来调用方法。这是由于Go在<strong>背后</strong>做了转换，如下所示。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line">lisa := &amp;user&#123;&#125;</span><br><span class="line">lisa.notify()</span><br><span class="line"><span class="comment">// Go背后的动作</span></span><br><span class="line">(*lisa).notify()</span><br><span class="line"><span class="comment">// 同理接受者是指针时</span></span><br><span class="line">(&amp;lisa).notify()</span><br></pre></td></tr></table></figure><h2 id="类型的本质"><a href="#类型的本质" class="headerlink" title="类型的本质"></a>类型的本质</h2><p>方法是传递指针还是值？</p><p>不是根据创建一个新值就使用值接受者，修改值就使用指针接受者。而是依据类型的本质。</p><p>在讨论类型的本质之前，我们先来看下以下三种类型。</p><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>内置类型：数值类型、字符串类型、布尔类型。对这些值增加或删除时，会创建一个新值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Trim</span><span class="params">(s <span class="keyword">string</span>, cutset <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原始本质</p></blockquote><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型：切片、映射、接口和函数类型。声明这些类型的变量，这个变量被称为标头（header），header里面包含指针，所以引用类型值的副本，本质上就是共享底层数据结构。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxx</span><span class="params">(xx []<span class="keyword">byte</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>引用类型的值也跟内置类型一样对待，原始本质。</p></blockquote><h3 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h3><p>结构类型的本质可以是原始的，也可以是非原始的。大多数情况下结构类型是非原始的。</p><p>原始本质。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准库的Time类型</span></span><br><span class="line"><span class="keyword">type</span> Time <span class="keyword">struct</span> &#123;</span><br><span class="line">    sec<span class="keyword">int64</span></span><br><span class="line">    nsec<span class="keyword">int32</span></span><br><span class="line">    loc*Location</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Now</span><span class="params">()</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Time)</span> <span class="title">Add</span><span class="params">(d Duration)</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非原始本质。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 标准库中File类型</span></span><br><span class="line"><span class="keyword">type</span> File <span class="keyword">struct</span> &#123;</span><br><span class="line">    *file</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> file <span class="keyword">struct</span> &#123;</span><br><span class="line">    fd <span class="keyword">int</span></span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    dirinfo*dirInfo</span><br><span class="line">    nepipe<span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(file *File, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> OpenFile(name, O_RDONLY, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *File)</span> <span class="title">Chdir</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrInvalid</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> e := syscall.Fchdir(f.fd); e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;PathError&#123;<span class="string">"chdir"</span>, f.name, e&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>由于File类型的值是不能安全复制的(不允许多个File变量操作同一个文件)，所以采用内嵌类型阻止其复制。</li><li>Chdir方法并没有修改File的值，但还是使用指针。说明如果类型是非原始本质的，接受者就需要是指针类型的。</li><li>第2点有个例外是，当类型值符合某个接口时候，即便类型的本质是非原始的，也可以使用值接受者声明方法。</li></ol></blockquote><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>实现接口，体现了事物的多态。只要实现某接口的类型值，都可以传入使用该接口的地方。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r, err := http.Get(os.Args[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">io.Copy(os.Stdout, r.Body)</span><br><span class="line"><span class="keyword">if</span> err := r.Body.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中os.Stdout实现了io.Writer接口，r.Body实现了io.Reader接口。</p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。<img src="实体值赋值后接口值的简图.jpg" alt="实体值赋值后接口值的简图"><img src="实体指针赋值后接口值的简图.jpg" alt="实体指针赋值后接口值的简图"></p><h3 id="方法集"><a href="#方法集" class="headerlink" title="方法集"></a>方法集</h3><p>方法集定义了接口的接受规则。当接受者是值的时候方法集包括指针和值，当接受者是指针的时候方法集只能是指针。</p><table><thead><tr><th style="text-align:left">Methods Receivers</th><th style="text-align:left">Values</th></tr></thead><tbody><tr><td style="text-align:left">(t  T)</td><td style="text-align:left">T and *T</td></tr><tr><td style="text-align:left">(t  *T)</td><td style="text-align:left">*T</td></tr></tbody></table><p>代码解释：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// duration 是一个基于 int 类型的类型</span></span><br><span class="line"><span class="keyword">type</span> duration <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 使用更可读的方式格式化 duration 值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *duration)</span> <span class="title">pretty</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Duration: %d"</span>, *d)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main 是应用程序的入口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    duration(<span class="number">42</span>).pretty()</span><br><span class="line">    <span class="comment">// ./listing46.go:17: 不能通过指针调用 duration(42)的方法</span></span><br><span class="line">    <span class="comment">// ./listing46.go:17: 不能获取 duration(42)的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码说明了，可能会出现取不到类型地址的情况出现。所以如果接受类型是指针就不允许值调用。</p></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    email<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending user email to %s&lt;%s&gt;\n"</span>, u.name, u.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    email<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *admin)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"Sending admin email to %s&lt;%s&gt;\n"</span>, a.name, a.email)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    bill := user&#123;<span class="string">"Bill"</span>, <span class="string">"bill@email.com"</span>&#125;</span><br><span class="line">    sendNotification(&amp;bill)</span><br><span class="line">    </span><br><span class="line">    lisa := amdin&#123;<span class="string">"Lisa"</span>, <span class="string">"lisa@email.com"</span>&#125;</span><br><span class="line">    sendNotification(&amp;lisa)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌入类型"><a href="#嵌入类型" class="headerlink" title="嵌入类型"></a>嵌入类型</h2><p>通过嵌入类型我们可以扩展和修改已有类型的行为。这个功能可以对代码进行复用。被嵌入的类型称为新的外部类型的内部类型。内部类型的标识符或方法会提升到外部类型上，可以在外部类型上声明与内部类型同名的标识符覆盖内部标识符或方法。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    email<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user <span class="comment">// 嵌入类型</span></span><br><span class="line">    level<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ad := admin &#123;</span><br><span class="line">        user: user &#123;</span><br><span class="line">            name: <span class="string">"denyu"</span></span><br><span class="line">            email: <span class="string">"extrnight@126.com"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">"super"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接访问</span></span><br><span class="line">    ad.user.notify()</span><br><span class="line">    <span class="comment">// 提升到外部访问</span></span><br><span class="line">    ad.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果嵌入类型实现某接口，外部类型也会实现这个接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> notifier <span class="keyword">interface</span> &#123;</span><br><span class="line">    notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name<span class="keyword">string</span></span><br><span class="line">    email<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">notify</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">    level<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部类型重写notify方法</span></span><br><span class="line"><span class="comment">//func (a *admin) notify() &#123;</span></span><br><span class="line"><span class="comment">//    ...</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ad := admin &#123;</span><br><span class="line">        user: user &#123;</span><br><span class="line">            name: <span class="string">"denyu"</span></span><br><span class="line">            email: <span class="string">"extrnight@126.com"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        level: <span class="string">"super"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sendNotification(&amp;ad)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendNotification</span><span class="params">(n notifier)</span></span> &#123;</span><br><span class="line">    n.notify()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公开或未公开的标识符"><a href="#公开或未公开的标识符" class="headerlink" title="公开或未公开的标识符"></a>公开或未公开的标识符</h2><ul><li>首字母大写 — 公开</li><li>首字母小写 — 未公开</li></ul><p>未公开的标识符，其他包不能直接访问到。但是可以通过下面的方式提供给其他包使用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> counters</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> alertCounter <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(value <span class="keyword">int</span>)</span> <span class="title">alertCounter</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> alertCounter(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    counter := counters.New(<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">"Counter: %d\n"</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内嵌类型中的公开未公开。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entities</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name<span class="keyword">string</span></span><br><span class="line">    Email<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Admin <span class="keyword">struct</span> &#123;</span><br><span class="line">    user</span><br><span class="line">    Level<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := entities.Admin &#123;</span><br><span class="line">        Level: <span class="string">"super"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    a.Name = <span class="string">"Bill"</span></span><br><span class="line">    a.Email = <span class="string">"bill@email.com"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// error a.user.Name</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>由于user类型是未公开的，所以无法直接通过字面量的方式初始化，但是其内部的标识符是公开的，被提升到了外部类型。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>方法提供了为用户定义的类型增加行为的方式。</li><li>设计类型时需要确认类型本质是原始的，还是非原始的。</li><li>接口是声明了一组行为并支持多态的类型。</li><li>嵌入类型提供了扩展类型的能力，而无需使用继承。</li><li>标识符要么公开，要么未公开。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring DI &amp; AOP</title>
      <link href="/2019/03/11/Spring-DI-AOP/"/>
      <url>/2019/03/11/Spring-DI-AOP/</url>
      
        <content type="html"><![CDATA[<h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI 依赖注入"></a>DI 依赖注入</h2><p>通常我们分不清IoC与DI有什么区别，在spring中他们是相同概念的，IOC是通过DI实现的。</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>DI使用组合的思想而非继承，其目的是为了解耦。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>spring Ioc容器（ApplicationContext）负责创建Bean，通过容器将Bean注入到你需要的Bean中。可通过xml、注解、java配置实现Bean的创建和注入。</p><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>声明Bean的注解：<br>@Component    没有明确角色<br>@Service        业务逻辑层使用<br>@Repository    数据访问层使用<br>@Controller    表示层使用</p><p>注入Bean的注解：<br>@Autowired    最好注解到属性上，可使代码更少</p><p>编写功能Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.di;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">FunctionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span> + word + <span class="string">" !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入使用Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.di;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">UseFunctionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    FunctionService functionService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> functionService.sayHello(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.demo.di"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Annotation是注释的意思</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(DiConfig.class);</span><br><span class="line">    </span><br><span class="line">    UseFunctionService useFunctionService = </span><br><span class="line">        context.getBean(UseFunctionService.class);</span><br><span class="line">    </span><br><span class="line">    useFunctionService.SayHello(<span class="string">"di"</span>);</span><br><span class="line">    </span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java配置"><a href="#java配置" class="headerlink" title="java配置"></a>java配置</h4><p>通过@Configuration 和 @Bean来实现</p><p>编写功能Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.di;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">FunctionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span> + word + <span class="string">" !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用功能Bean</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.di;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">UseFunctionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FunctionService functionService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFunctionService</span><span class="params">(FunctionService functionService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.functionService = functionService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> functionService.sayHello(word);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FunctionService <span class="title">functionService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FuntionService();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UseFunctionService <span class="title">useFunctionService</span><span class="params">(FunctionService functionService)</span> </span>&#123;</span><br><span class="line">        UseFunctionService useFunctionService =  <span class="keyword">new</span> UseFunctionService();</span><br><span class="line">    useFunctionService.setFunctionService(functionService);</span><br><span class="line">        <span class="comment">// 第二种注入方式：</span></span><br><span class="line">        <span class="comment">// 如果UseFunctionService未传参functionService</span></span><br><span class="line">        <span class="comment">// useFunctionService.setFunctionService(functionService());</span></span><br><span class="line">        <span class="keyword">return</span> useFunctionService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同注解配置</span><br></pre></td></tr></table></figure><blockquote><p>在全局配置中使用java配置（如数据库相关配置），业务Bean的配置用注解配置。</p></blockquote><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP 面向切面编程"></a>AOP 面向切面编程</h2><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>为了接耦，让一组类共享相同的行为。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>spring支持AspectJ的注解式切面编程<br>@Aspect    声明是一个切片<br>@After        拦截后前执行<br>@Before    拦截之前执行<br>@Around    同时在拦截前后执行</p><p>添加spring aop支持及AspectJ依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--aop支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aspectj支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注解式拦截"><a href="#注解式拦截" class="headerlink" title="注解式拦截"></a>注解式拦截</h4><p>拦截规则的注解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.demo.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Action &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被拦截类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoAnnotationService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Action</span>(name = <span class="string">"注解式拦截的add操作"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"注解拦截服务运行中。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写切面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.demo.aop.Action)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"annotationPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Action action = method.getAnnotation(Action.class);</span><br><span class="line">        System.out.println(<span class="string">"注解式拦截 "</span> + action.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.demo.aop"</span>)</span><br><span class="line"><span class="comment">// 开启Spring 对 AspectJ代理支持</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);</span><br><span class="line"></span><br><span class="line">    DemoAnnotationService demoAnnotationService = </span><br><span class="line">        context.getBean(DemoAnnotationService.class);</span><br><span class="line"></span><br><span class="line">    demoAnnotationService.add();</span><br><span class="line"></span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法式拦截"><a href="#方法式拦截" class="headerlink" title="方法式拦截"></a>方法式拦截</h4><p>被拦截类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMethodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法拦截服务运行中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写切面</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.demo.aop.DemoMethodService.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        System.out.println(<span class="string">"方法规则式拦截，"</span> + method.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同注解式拦截</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);</span><br><span class="line"></span><br><span class="line">    DemoMethodService demoMethodService = </span><br><span class="line">        context.getBean(DemoMethodService.class);</span><br><span class="line">    </span><br><span class="line">    demoMethodService.add();</span><br><span class="line">    </span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在springboot项目中@EnableAutoConfiguration默认开启@EnableAspectJAutoProxy。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-数组、切片和映射</title>
      <link href="/2019/03/08/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/"/>
      <url>/2019/03/08/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E6%95%B0%E7%BB%84%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一个长度固定的数据类型，用于存储相同类型元素的连续块。</p><h3 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h3><p>占用内存是连续分配的，容易计算索引。</p><p><img src="数组的内部实现.jpg" alt="数组的内部实现"></p><h3 id="声明和初始化"><a href="#声明和初始化" class="headerlink" title="声明和初始化"></a>声明和初始化</h3><p>声明一个数组，并初始化为零值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>使用数组字面量声明数组。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法1</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="comment">// 容量由初始化值的数量决定。</span></span><br><span class="line">array := [...]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br></pre></td></tr></table></figure><p>声明数组并指定特定元素的值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体初始化索引为1和2的元素，其余元素保持零值</span></span><br><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: <span class="number">10</span>, <span class="number">2</span>: <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一旦声明，数组存储的类型和长度就都不能改变了。如果需要存更多元素，就需要先创建一个更长的数组，再把旧的数组复制到新的数组里。</p></blockquote><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>访问数组元素。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">array[<span class="number">2</span>] = <span class="number">35</span></span><br></pre></td></tr></table></figure><p>访问指针数组元素。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">array := [<span class="number">5</span>]*<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="built_in">new</span>(<span class="keyword">int</span>), <span class="number">1</span>: <span class="built_in">new</span>(<span class="keyword">int</span>)&#125;</span><br><span class="line">*array[<span class="number">0</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>同类型的数组赋值给另一个数组。</p><p>只有数组长度和元素的类型都相同的数组，才能互相赋值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 [<span class="number">5</span>]<span class="keyword">string</span></span><br><span class="line">array2 := [<span class="number">5</span>]<span class="keyword">string</span>&#123;<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"White"</span>&#125;</span><br><span class="line"></span><br><span class="line">array1 = array2</span><br></pre></td></tr></table></figure><p>指针数组赋值给另一个，两个数组指向同一组字符串。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 [<span class="number">3</span>]*<span class="keyword">string</span></span><br><span class="line">array2 := [<span class="number">3</span>]*<span class="keyword">string</span>&#123;<span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>), <span class="built_in">new</span>(<span class="keyword">string</span>)&#125;</span><br><span class="line"></span><br><span class="line">*array2[<span class="number">0</span>] = <span class="string">"Red"</span></span><br><span class="line">*array2[<span class="number">1</span>] = <span class="string">"Blue"</span></span><br><span class="line">*array2[<span class="number">2</span>] = <span class="string">"Green"</span></span><br><span class="line"></span><br><span class="line">array1 = array2</span><br></pre></td></tr></table></figure><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>声明二维数组。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">array := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>, <span class="number">11</span>&#125;, &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, &#123;<span class="number">30</span>, <span class="number">31</span>&#125;, &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">array := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">20</span>, <span class="number">21</span>&#125;, <span class="number">3</span>: &#123;<span class="number">40</span>, <span class="number">41</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">array := [<span class="number">4</span>][<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>: &#123;<span class="number">0</span>: <span class="number">20</span>&#125;, <span class="number">3</span>: &#123;<span class="number">1</span>: <span class="number">41</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>访问二维数组的元素。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">array[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>同类型多维数组赋值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> array2 [<span class="number">2</span>][<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">array2[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">array2[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">array1 = array</span><br></pre></td></tr></table></figure><p>独立复制数组的某个维度。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array3 [<span class="number">2</span>]<span class="keyword">int</span> = array1[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">var</span> value <span class="keyword">int</span> = array1[<span class="number">1</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><h3 id="在函数间传递数组"><a href="#在函数间传递数组" class="headerlink" title="在函数间传递数组"></a>在函数间传递数组</h3><p>如果函数接受一个100万个整型值的数组，每次函数调用时，必须在栈上分配8MB的内存。之后数组的值被分配到刚分配的内存中。如何更好的利用内存，优化性能？可以只传入数组指针，也可以使用切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array [<span class="number">1e6</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">foo(&amp;array)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span> <span class="params">(array *[1e6]<span class="keyword">int</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><h3 id="内部实现-1"><a href="#内部实现-1" class="headerlink" title="内部实现"></a>内部实现</h3><p><img src="切片的内部实现.jpg" alt="切片的内部实现"></p><h3 id="创建和初始化"><a href="#创建和初始化" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><p>只指定长度，使用make函数声明切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>只指定长度，那么切片的容量和长度相等。</p></blockquote><p>指定长度和容量，使用make声明切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>上诉切片可以访问 3 个元素，而底层数组拥有 5 个元素。剩余的 2 个元素可以在后期操作中合并到切片，就可访问到。</p></blockquote><p>不允许容量小于长度。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>切片字面量声明切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"Red"</span>, <span class="string">"Yellow"</span>, <span class="string">"Blue"</span>&#125;</span><br></pre></td></tr></table></figure><p>使用索引声明切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建长度和容量都为100的切片，并初始化第100个元素。</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="number">99</span>: <span class="string">""</span>&#125;</span><br></pre></td></tr></table></figure><p>声明数组与切片的不同。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明数组</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="comment">// 声明切片</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><p>nil和空切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p><img src="nil切片的表示.jpg" alt="nil切片的表示"></p><blockquote><p>只要在声明时不做任何初始化，就会创建一个nil切片。<br>应用场景：<br>需要描述一个不存在的切片时。例如，函数要求返回一个切片但是发生异常的时候。</p></blockquote><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明方式1</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 声明方式2</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="空切片的表示.jpg" alt="空切片的表示"></p><blockquote><p>空切片是底层数组包含0个元素，也没有分配任何存储空间。<br>应用场景：<br>表示空集合。例如，数据库查询返回0个查询结果时。</p></blockquote><h3 id="使用切片"><a href="#使用切片" class="headerlink" title="使用切片"></a>使用切片</h3><p>与数组中的索引指向元素赋值的方法一样，使用[]操作符就可以操作某个元素的值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">25</span></span><br></pre></td></tr></table></figure><p>使用切片创建切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 其长度为2，容量为4。</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">35</span></span><br></pre></td></tr></table></figure><p><img src="使用切片创建切片.jpg" alt="使用切片创建切片"></p><blockquote><p>计算公式 slice[i:j]，k: 为切片容量。<br>长度：j - i        (3 - 1)<br>容量：k - i        (5 - 1)<br>注：修改了newSlice索引为1的元素，同时也会修改slice的索引为2的元素。</p></blockquote><p>切片增长</p><p>append()调用返回时，会返回一个包含修改结果的新切片。append总会增加新切片的长度，而容量有可能会改变，也可能不会改变。这取决于被操作的切片的可用容量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p><img src="append之后的底层数组.jpg" alt="append之后的底层数组"></p><blockquote><p>由于newSlice在底层数组还有额外的容量可用，append操作将可用的元素合并到切片的长度，并对其赋值60，由于和原始的slice共享同一个底层数组，slice中索引为3的元素的值也被改动了。</p></blockquote><p>如果切片的底层数组没有足够的容量可用，append操作将会创建一个新的底层数组，将被引用的现有值复制到新数组里，再追加新的值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">newSlice := <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p><img src="append操作后的新的底层数组.jpg" alt="append操作后新的底层数组"></p><blockquote><p>切片容量小于1000时，总是会成倍增加容量。一旦超过1000，容量的增长因子会设为1.25。随着语言的迭代，这种增长算法有可能会改变。</p></blockquote><p>创建切片时的三个索引</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">source := []<span class="keyword">string</span>&#123;<span class="string">"Apple"</span>, <span class="string">"Orange"</span>, <span class="string">"Plum"</span>, <span class="string">"Banana"</span>, <span class="string">"Grape"</span>&#125;</span><br><span class="line"><span class="comment">// 长度为1，容量为1。</span></span><br><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>计算公式 slice[i:j:k]<br>长度：j - i         (3 - 2)<br>容量：k - i         (3 - 2)</p><p>设置长度和容量一样的好处，如果不加第三个索引，剩余容量都属于slice，向slice追加元素会改变source底层数组索引3的元素值。不过在上面我们对slice的容量限制为1。当我们对slice调用append的时候，会创建一个新的底层数组。这样就不会在修改slice时，可能改到source切片。</p></blockquote><p>设置容量大于已有容量会出现运行时错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := source[<span class="number">2</span>:<span class="number">3</span>:<span class="number">6</span>]</span><br></pre></td></tr></table></figure><p>将一个切片追加到另外一个切片上</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用...运算符。</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s3 := <span class="built_in">append</span>(s1, s2...)</span><br></pre></td></tr></table></figure><p>迭代切片</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> s1 &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略索引，使用占位符_。</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> s1&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(s3); index++ &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>index是元素索引。<br>value是元素副本。</p><p>传统for循环迭代切片可以对迭代更多控制，比如从索引为2开始迭代.。</p></blockquote><h3 id="多维切片"><a href="#多维切片" class="headerlink" title="多维切片"></a>多维切片</h3><p>声明多维切片</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>, <span class="number">200</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="切片的切片.jpg" alt="切片的切片"></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := [][]<span class="keyword">int</span>&#123;&#123;<span class="number">10</span>&#125;, &#123;<span class="number">100</span>, <span class="number">200</span>&#125;&#125;</span><br><span class="line">slice[<span class="number">0</span>] = <span class="built_in">append</span>(slice[<span class="number">0</span>], <span class="number">20</span>)</span><br></pre></td></tr></table></figure><blockquote><p>多维切片可以让用户创建非常复杂且强大的数据结构。已经学过的关于内置函数 append的规则也可以应用到其上。</p></blockquote><h3 id="在函数间传递切片"><a href="#在函数间传递切片" class="headerlink" title="在函数间传递切片"></a>在函数间传递切片</h3><p>传递切片的成本很低，在64位机器上，一个切片需要24字节：指针8字节，长度和容量分别8字节。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">1e6</span>)</span><br><span class="line">slice = foo(slice)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(slice []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> slice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="在函数间传递切片.jpg" alt="在函数间传递切片"></p><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><h3 id="内部实现-2"><a href="#内部实现-2" class="headerlink" title="内部实现"></a>内部实现</h3><ol><li><p>映射的键通过散列函数生成散列值。</p></li><li><p>散列值的低八位被用来选择桶。</p></li><li><p>散列值的高八位存放在桶中的数组中，用来区分不同项。</p></li><li><p>键值对以字节数组的方式存放在桶中。</p></li></ol><blockquote><p>键值对以字节数组存储，先存键，再存值。为何不 key value key value …存储，而要key key… value value…存储？</p><p>答：是由于字节对齐会导致空间浪费，按照第二种方式存储可以减少浪费。</p><p>比如：key占用2个字节，value占用4个字节。其中1代表使用，0代表浪费。</p><p>第一种 ：{1 1 0 0}{1 1 1 1}{1 1 0 0}{1 1 1 1}{1 1 0 0}{1 1 1 1} 浪费6<br>第二种：{1 1 1 1}{1 1 0 0}{1 1 1 1}{1 1 1 1}{1 1 1 1} 浪费2</p></blockquote><p><img src="映射的内部结构简单表示.jpg" alt="映射的内部结构"></p><h3 id="创建和初始化-1"><a href="#创建和初始化-1" class="headerlink" title="创建和初始化"></a>创建和初始化</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用make声明映射</span></span><br><span class="line">dict := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line"><span class="comment">// 使用字面量声明</span></span><br><span class="line">dict := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"Red"</span>: <span class="string">"#da1337"</span>, <span class="string">"Orange"</span>: <span class="string">"#e95a22"</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line">dict := <span class="built_in">make</span>[[]<span class="keyword">string</span>]<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li>映射的键不能是切片、函数、以及包含切片的数据结构类型，这些类型具有引用语义。</li><li>映射的值不作限制。</li></ol></blockquote><h3 id="使用映射"><a href="#使用映射" class="headerlink" title="使用映射"></a>使用映射</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">colors := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line">colors[<span class="string">"Red"</span>] = <span class="string">"#da1337"</span></span><br></pre></td></tr></table></figure><p>对 nil 映射赋值时的语言运行时错误</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">// 声明nil映射</span></span><br><span class="line"><span class="keyword">var</span> colors <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">colors[<span class="string">"Red"</span>] = <span class="string">"#da1337"</span></span><br></pre></td></tr></table></figure><p>从映射获取值并判断键是否存在</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, exists := colors[<span class="string">"Blue"</span>]</span><br><span class="line"><span class="keyword">if</span> exists &#123;&#125;</span><br></pre></td></tr></table></figure><p>使用range迭代映射</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">colors := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line"><span class="string">"AliceBlue"</span>:<span class="string">"#f0f8ff"</span>,</span><br><span class="line"><span class="string">"Coral"</span>:<span class="string">"#ff7F50"</span>,</span><br><span class="line">    <span class="string">"DarkGray"</span>:<span class="string">"#a9a9a9"</span>,</span><br><span class="line">    <span class="string">"ForestGreen"</span>:<span class="string">"#228b22"</span>,</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> colors &#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实go按照经典的hashmap实现。只要值固定了不再修改，那么每次遍历的结果应该是一样的，但是Go工程师做了点小处理。对key次序做随机化，以提醒大家不要依赖range遍历返回的key次序。</p></blockquote><p>从映射中删除一项</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用内置的delete函数</span></span><br><span class="line"><span class="built_in">delete</span>(colors, <span class="string">"Coral"</span>)</span><br></pre></td></tr></table></figure><h3 id="在函数间传递映射"><a href="#在函数间传递映射" class="headerlink" title="在函数间传递映射"></a>在函数间传递映射</h3><p>函数间传递映射并不会制造出该映射的一个副本。当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">colors := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;</span><br><span class="line">        <span class="string">"AliceBlue"</span>: <span class="string">"#f0f8ff"</span>,</span><br><span class="line">        <span class="string">"Coral"</span>: <span class="string">"#ff7F50"</span>,</span><br><span class="line">        <span class="string">"DarkGray"</span>: <span class="string">"#a9a9a9"</span>,</span><br><span class="line">        <span class="string">"ForestGreen"</span>: <span class="string">"#228b22"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> colors &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %s Value: %s\n"</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    removeColor(colors, <span class="string">"Coral"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> colors &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Key: %s Value: %s\n"</span>, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeColor</span><span class="params">(colors <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">delete</span>(colors, key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">Key: AliceBlue Value: #F0F8FF</span><br><span class="line">Key: Coral Value: #FF7F50</span><br><span class="line">Key: DarkGray Value: #A9A9A9</span><br><span class="line">Key: ForestGreen Value: #<span class="number">228</span>B22</span><br><span class="line"></span><br><span class="line">Key: AliceBlue Value: #F0F8FF</span><br><span class="line">Key: DarkGray Value: #A9A9A9</span><br><span class="line">Key: ForestGreen Value: #<span class="number">228</span>B22</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>数组是构造切片和映射的基石</li><li>切片有容量限制，不过可以使用内置的 append 函数扩展容量。</li><li>映射的增长没有容量或者任何限制。</li><li>内置函数 len 可以用来获取切片或者映射的长度。</li><li>内置函数 cap 只能用于切片。</li><li>将切片或者映射传递给函数成本很小，并且不会复制底层的数据结构。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-打包和工具链</title>
      <link href="/2019/03/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/"/>
      <url>/2019/03/03/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E6%89%93%E5%8C%85%E5%92%8C%E5%B7%A5%E5%85%B7%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>所有的Go语言都会被组织成若干组文件，每组文件被称为一个包。同一个目录下的所有.go 文件必须声明同一个包名。</p><h3 id="包命名的惯例"><a href="#包命名的惯例" class="headerlink" title="包命名的惯例"></a>包命名的惯例</h3><p>给包命名的惯例就是使用包所在目录的名字。这会让用户在导入包的时候，就可以清晰地知道包名。给包及其目录命名时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。</p><p>当包名不为目录名：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">工程目录如下：</span><br><span class="line">.</span><br><span class="line">├── config.json</span><br><span class="line">├── main.<span class="keyword">go</span></span><br><span class="line">└── usb</span><br><span class="line">    ├── doc.<span class="keyword">go</span></span><br><span class="line">    └── driver.<span class="keyword">go</span></span><br><span class="line"><span class="comment">// 其中usb目录下的go文件，包名设置为usb_1。</span></span><br><span class="line"><span class="comment">// 在main.go中使用driver下的函数，代码如下所示：</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"github.com/demo/usb"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这样调用，包名和导入的目录名不一致，会导致代码不清晰。</span></span><br><span class="line">    usb_1.Retrieve()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="main-包"><a href="#main-包" class="headerlink" title="main 包"></a>main 包</h3><p>当一个包的名字为main时，那么一定会发现名为main()的函数。Go语言会试图把命名为main的包编译为二进制可执行文件。</p><blockquote><p>Go 文档中常使用命令（command）这个词来指代可执行程序。作为对比，包常用来指语义上可导入的单元功能。</p></blockquote><h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>导入包需要关键字import。如果导入多个包，则将import语句包装到一个导入块中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>标准库中的包会在Go的安装位置（GOROOT）找到，Go开发者创建的包会在GOPATH路径下找到。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GOROOT=/usr/local/Cellar/go/1.11.2/libexec</span><br><span class="line">GOPATH=/Users/mike/go</span><br></pre></td></tr></table></figure><h3 id="远程导入"><a href="#远程导入" class="headerlink" title="远程导入"></a>远程导入</h3><p>目前的大势所趋是，使用分布式版本控制系统（Distributed Version Control Systems，DVCS）来分享代码，如Github、Launchpad还有Bitbucket。Go工具链本身支持从这些网站上及类似网站获取源代码。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果要 import "github.com/spf13/viper"</span></span><br><span class="line"><span class="comment">// 使用如下命令</span></span><br><span class="line"><span class="comment">// 这个命令会扫描某个包的源码树，获取能找到的所有依赖包</span></span><br><span class="line"><span class="keyword">go</span> get <span class="string">"github.com/spf13/viper"</span></span><br></pre></td></tr></table></figure><h3 id="命名导入"><a href="#命名导入" class="headerlink" title="命名导入"></a>命名导入</h3><p>如果导入两个以上相同名字的包，如fmt和mylib/fmt，这种情况下，重名的包可以通过命名导入来导入。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    myfmt <span class="string">"mylib/fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"标准库fmt"</span>)</span><br><span class="line">    myfmt.Println(<span class="string">"自定义fmt"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数init"><a href="#函数init" class="headerlink" title="函数init"></a>函数init</h2><p>所有被编译器发现的init 函数都会在 main 函数之前执行。一般是为了要在程序运行前优先完成引导工作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这段示例代码包含在 PostgreSQL 数据库的驱动里</span></span><br><span class="line"><span class="comment">// 如果程序导入了这个包，就会调用 init 函数</span></span><br><span class="line"><span class="comment">// 促使 PostgreSQL 的驱动最终注册到 Go 的 sql 包里，成为一个可用的驱动。</span></span><br><span class="line"><span class="keyword">package</span> postgres</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">sql.Register(<span class="string">"postgres"</span>, <span class="built_in">new</span>(PostgresDriver))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><figcaption><span>package main0203 import (04 "database/sql"0506 _ "github.com/goinaction/code/chapter3/dbdriver/postgres"07 )0809 func main() &#123;10 sql.Open("postgres", "mydb")11 &#125; </span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用空白标识符重命名这个导入可以让 init 函数发现并被调度运行</span></span><br><span class="line"><span class="comment">// 这样就可以调用 sql.Open 方法来使用 PostgreSQL 驱动</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"database/sql"</span></span><br><span class="line">    </span><br><span class="line">    _ <span class="string">"github.com/goinaction/code/chapter3/dbdriver/postgres"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sql.Open(<span class="string">"postgres"</span>, <span class="string">"mydb"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Go的工具"><a href="#使用Go的工具" class="headerlink" title="使用Go的工具"></a>使用Go的工具</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> build - 编译</span><br><span class="line"><span class="keyword">go</span> clean - 清除编译后的可执行文件</span><br><span class="line"><span class="keyword">go</span> run - 编译运行</span><br><span class="line"><span class="keyword">go</span> vet ./... - 检查代码常见错误</span><br><span class="line"><span class="keyword">go</span> fmt ./... - 格式化代码</span><br><span class="line"><span class="keyword">go</span> doc - 查阅xx包的相关文档</span><br><span class="line">godoc -http=:<span class="number">6060</span> - 浏览器 http:<span class="comment">//localhost:6060 查看相关文档</span></span><br></pre></td></tr></table></figure><h2 id="与其他Go开发者合作"><a href="#与其他Go开发者合作" class="headerlink" title="与其他Go开发者合作"></a>与其他Go开发者合作</h2><ol><li>包应该在代码库的根目录，包名应该就是代码库的名字</li><li>包可以非常小</li><li>对代码执行go fmt</li><li>给代码写文档</li></ol><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><p>官方推荐的Dep管理包依赖（支持Go1.9及以上版本）</p><p>MacOS</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span> brew install dep</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> get -u github.com/golang/dep/cmd/dep</span><br></pre></td></tr></table></figure><p>这样就有dep命令可以使用了，最常用的就两条命令：dep init和dep ensure。</p><ol><li>对于新项目，执行dep init命令生成dep配置文件（Gopkg.lock Gopkg.toml ）和 vendor目录。提交代码时，也会把Gopkg.*和vendor目录提交。</li><li>在开发过程中，若增改了依赖，一条dep ensure就可以搞定。</li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>在Go语言中包是组织代码的基本单位。</li><li>环境变量 GOPATH 决定了 Go 源代码在磁盘上被保存、编译和安装的位置。</li><li>开发人员可以使用 go get 来获取别人的包并将其安装到自己的 GOPATH 指定的目录</li><li>想要为别人创建包很简单，只要把源代码放到公用代码库，并遵守一些简单规则就可以了。</li><li>Go 语言在设计时将分享代码作为语言的核心特性和驱动力。</li><li>推荐使用dep管理工具来管理依赖。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go Viper - 初探</title>
      <link href="/2019/02/28/Go-Viper-%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/02/28/Go-Viper-%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Viper？"><a href="#什么是Viper？" class="headerlink" title="什么是Viper？"></a>什么是Viper？</h2><p>Viper是配置文件的解决方案。支持：</p><ul><li>设置默认配置。</li><li>从 JSON，TOML，YAML，HCL，Java properties 的文件中读取配置。</li><li>实时重新读取配置文件。</li><li>从远程读取配置，可观察到配置文件的改变。</li><li>从命令行参数读取配置（command line flags）</li><li>从缓存中读取配置</li><li>设置明确值的配置</li></ul><h2 id="Viper读取配置优先级"><a href="#Viper读取配置优先级" class="headerlink" title="Viper读取配置优先级"></a>Viper读取配置优先级</h2><ul><li>Set明确设置的配置</li><li>io.Reader读取配置</li><li>命令行参数</li><li>环境变量</li><li>配置文件</li><li>key/value存储</li><li>默认配置</li></ul><h2 id="Viper使用示例"><a href="#Viper使用示例" class="headerlink" title="Viper使用示例"></a>Viper使用示例</h2><h3 id="Set明确设置的配置"><a href="#Set明确设置的配置" class="headerlink" title="Set明确设置的配置"></a>Set明确设置的配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优先级最高，覆盖其他来源的denyu配置</span></span><br><span class="line">viper.Set(<span class="string">"denyu"</span>, <span class="string">"陈宇"</span>)</span><br></pre></td></tr></table></figure><h3 id="io-Reader中读取配置"><a href="#io-Reader中读取配置" class="headerlink" title="io.Reader中读取配置"></a>io.Reader中读取配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetConfigType(<span class="string">"yaml"</span>)</span><br><span class="line"><span class="keyword">var</span> yamlExample = []<span class="keyword">byte</span>(<span class="string">`</span></span><br><span class="line"><span class="string">name: denyu</span></span><br><span class="line"><span class="string">hobbies:</span></span><br><span class="line"><span class="string">- go</span></span><br><span class="line"><span class="string">- java</span></span><br><span class="line"><span class="string">clothing:</span></span><br><span class="line"><span class="string">jacket: leather</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line">viper.ReadConfig(bytes.NewBuffer(yamlExample))</span><br><span class="line"></span><br><span class="line">viper.Get(<span class="string">"name"</span>) <span class="comment">// this would be "denyu"</span></span><br></pre></td></tr></table></figure><h3 id="命令行读取配置"><a href="#命令行读取配置" class="headerlink" title="命令行读取配置"></a>命令行读取配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pflag.Int(<span class="string">"flagname"</span>, <span class="number">1234</span>, <span class="string">"help message for flagname"</span>)</span><br><span class="line"></span><br><span class="line">pflag.Parse()</span><br><span class="line">viper.BindPFlags(pflag.CommandLine)</span><br><span class="line"></span><br><span class="line">i := viper.GetInt(<span class="string">"flagname"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一般程序用的都是内置flag</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"flag"</span></span><br><span class="line"><span class="string">"github.com/spf13/pflag"</span></span><br><span class="line">    ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">flag.Int(<span class="string">"flagname"</span>, <span class="number">1234</span>, <span class="string">"help message for flagname"</span>)</span><br><span class="line">    </span><br><span class="line">pflag.CommandLine.AddGoFlagSet(flag.CommandLine)</span><br><span class="line">pflag.Parse()</span><br><span class="line">viper.BindPFlags(pflag.CommandLine)</span><br><span class="line"></span><br><span class="line">i := viper.GetInt(<span class="string">"flagname"</span>)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环境变量中读取配置"><a href="#环境变量中读取配置" class="headerlink" title="环境变量中读取配置"></a>环境变量中读取配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="comment">// 这里环境变量的名字必须大写</span></span><br><span class="line">viper.SetEnvPrefix(<span class="string">"sss"</span>)</span><br><span class="line">BindEnv(<span class="string">"id"</span>)</span><br><span class="line">os.Setenv(<span class="string">"SSS_ID"</span>, <span class="string">"0001"</span>)</span><br><span class="line">id := Get(<span class="string">"id"</span>) <span class="comment">// 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="comment">// 如果BindEnv传第二个参数则不加前缀</span></span><br><span class="line"><span class="comment">// 环境变量名不一定大写</span></span><br><span class="line">viper.SetEnvPrefix(<span class="string">"sss"</span>)</span><br><span class="line">BindEnv(<span class="string">"id"</span>, <span class="string">"sSs_Id"</span>)</span><br><span class="line">os.Setenv(<span class="string">"sSs_Id"</span>, <span class="string">"0001"</span>)</span><br><span class="line">id := Get(<span class="string">"id"</span>) <span class="comment">// 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 3</span></span><br><span class="line">os.Setenv(<span class="string">"SSS_ID"</span>, <span class="string">"0001"</span>) </span><br><span class="line">viper.AutomaticEnv()</span><br><span class="line">id := viper.Get(<span class="string">"sss_id"</span>) <span class="comment">// 0001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// case 4</span></span><br><span class="line">SetEnvPrefix(<span class="string">"sss"</span>) </span><br><span class="line">os.Setenv(<span class="string">"SSS_ID"</span>, <span class="string">"0001"</span>) </span><br><span class="line">viper.AutomaticEnv()</span><br><span class="line">id := viper.Get(<span class="string">"id"</span>) <span class="comment">// 0001</span></span><br></pre></td></tr></table></figure><h3 id="配置文件中读取配置"><a href="#配置文件中读取配置" class="headerlink" title="配置文件中读取配置"></a>配置文件中读取配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetConfigName(<span class="string">"config"</span>)</span><br><span class="line">viper.AddConfigPath(<span class="string">"."</span>)</span><br><span class="line">err := viper.ReadInConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="远程key-value读取配置"><a href="#远程key-value读取配置" class="headerlink" title="远程key/value读取配置"></a>远程key/value读取配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"port"</span>: <span class="number">8080</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">viper.AddRemoteProvider(<span class="string">"consul"</span>, <span class="string">"localhost:8500"</span>, <span class="string">"MY_CONSUL_KEY"</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">"json"</span>) </span><br><span class="line">err := viper.ReadRemoteConfig()</span><br><span class="line"></span><br><span class="line">fmt.Println(viper.Get(<span class="string">"port"</span>)) <span class="comment">// 8080</span></span><br></pre></td></tr></table></figure><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.SetDefault(<span class="string">"denyu"</span>, <span class="string">"陈宇"</span>)</span><br></pre></td></tr></table></figure><h3 id="实时重新读取配置文件"><a href="#实时重新读取配置文件" class="headerlink" title="实时重新读取配置文件"></a>实时重新读取配置文件</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"sync"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"github.com/spf13/viper"</span></span><br><span class="line">    <span class="string">"github.com/fsnotify/fsnotify"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> waitGroup sync.WaitGroup</span><br><span class="line">    waitGroup.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    viper.SetConfigName(<span class="string">"config"</span>)</span><br><span class="line">    viper.AddConfigPath(<span class="string">"."</span>)</span><br><span class="line">    err := viper.ReadInConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(fmt.Errorf(<span class="string">"Fatal error config file: %s \n"</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实时重新读取配置文件</span></span><br><span class="line">    viper.WatchConfig()</span><br><span class="line">    <span class="comment">// 如果文件配置文件发生改变就会触发</span></span><br><span class="line">    viper.OnConfigChange(<span class="function"><span class="keyword">func</span><span class="params">(e fsnotify.Event)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Config file changed:"</span>, e.Name)</span><br><span class="line">        fmt.Println(viper.Get(<span class="string">"denyu"</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(viper.Get(<span class="string">"denyu"</span>))</span><br><span class="line">    </span><br><span class="line">    waitGroup.Wait()</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台打印数据如下</span></span><br><span class="line"><span class="comment">// 陈宇</span></span><br><span class="line"><span class="comment">// 当改变config.json文件时控制台打印如下</span></span><br><span class="line">    <span class="comment">// Config file changed: /Users/mike/go/src/github.com/demo/config.json</span></span><br><span class="line">    <span class="comment">// 陈宇1</span></span><br></pre></td></tr></table></figure><h3 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">viper.RegisterAlias(<span class="string">"dy"</span>, <span class="string">"mk"</span>)</span><br><span class="line"></span><br><span class="line">viper.Set(<span class="string">"dy"</span>, <span class="string">"denyu"</span>)</span><br><span class="line">viper.Set(<span class="string">"mk"</span>, <span class="string">"mike"</span>)</span><br><span class="line"></span><br><span class="line">viper.Get(<span class="string">"dy"</span>) <span class="comment">// denyu</span></span><br><span class="line">viper.Get(<span class="string">"mk"</span>) <span class="comment">// mike</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-快速开始一个Go程序</title>
      <link href="/2019/02/26/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/02/26/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AAGo%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过<a href="https://github.com/denyu95/go-in-action-code/tree/master/chapter2/sample" target="_blank" rel="noopener">例子</a>学习</p><ol><li>如何声明类型、变量、函数、方法</li><li>启动并同步操作goroutine</li><li>使用接口写通用的代码</li><li>处理程序逻辑和错误</li></ol><h2 id="功能简介"><a href="#功能简介" class="headerlink" title="功能简介"></a>功能简介</h2><p>该例子从不同的数据源拉取数据，将数据与检索项做对比，然后将匹配内容显示在终端窗口。该程序会读取文本文件，进行网络调用，解码XML和JSON成结构化类型数据，并用上并发机制来保障速度。</p><h2 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h2><p><img src="./架构图.jpg" alt="架构图"></p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- sample</span><br><span class="line">- data</span><br><span class="line">data.json -- 包含一组数据源</span><br><span class="line">- matchers</span><br><span class="line">rss.go -- 搜索 rss 源的匹配器</span><br><span class="line">- search</span><br><span class="line">default.go -- 搜索数据用的默认匹配器</span><br><span class="line">feed.go -- 用于读取 json 数据文件</span><br><span class="line">match.go -- 用于支持不同匹配器的接口</span><br><span class="line">search.go -- 执行搜索的主控制逻辑</span><br><span class="line">main.go -- 程序的入口</span><br></pre></td></tr></table></figure><h2 id="重点讲解"><a href="#重点讲解" class="headerlink" title="重点讲解"></a>重点讲解</h2><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p>程序的入口有两个特征：</p><ol><li>包名为main</li><li>名为main的函数</li></ol><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>包的名字类似于命名空间，可间接访问包内声明的标识符。同一个文件夹里的代码文件，必须使用同一个包名。这个特性可把不同包中定义的同名标识符区分开。</p><p>注意到下述代码中，包前加下划线。这是为了让Go语言对包做初始化操作（init函数），但是并不使用包里的标识符。Go编译器不允许导入包而不使用，下划线可让编译器接受这类导入。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"log"</span></span><br><span class="line">    </span><br><span class="line">    _ <span class="string">"github.com/denyu95/go-in-action-code/chapter2/sample/matchers"</span></span><br><span class="line">    <span class="string">"github.com/denyu95/go-in-action-code/chapter2/sample/search"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="init-函数"><a href="#init-函数" class="headerlink" title="init 函数"></a>init 函数</h3><p>init函数都会在main函数执行前调用。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.SetOutput(os.Stdout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译器如何找包"><a href="#编译器如何找包" class="headerlink" title="编译器如何找包"></a>编译器如何找包</h3><p>编译器查找包的时候，总是会到 GOROOT 和 GOPATH 环境变量引用的位置去查找。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GOROOT="/Users/me/go"</span><br><span class="line">GOPATH="/Users/me/spaces/go/projects"</span><br></pre></td></tr></table></figure><h3 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h3><p>声明一个结构类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Feed <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:"site"`</span></span><br><span class="line">    URI  <span class="keyword">string</span> <span class="string">`json:"link"`</span></span><br><span class="line">    Type <span class="keyword">string</span> <span class="string">`json:"type"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明最后 ` 引号里的部分被称作标记（tag）。这个标记描述了JSON解码的元数据，每个标记对应JSON文档中指定名字的字段。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"site"</span> : <span class="string">"cnn"</span>,</span><br><span class="line">    <span class="attr">"link"</span> : <span class="string">"http://rss.cnn.com/rss/cnn_world.rss"</span>,</span><br><span class="line">    <span class="attr">"type"</span> : <span class="string">"rss"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><ul><li>变量使用关键字 var声明</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matchers = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Matcher)</span><br></pre></td></tr></table></figure><ul><li>简化变量声明运算符（:=）</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">feeds, err := RetrieveFeeds()</span><br></pre></td></tr></table></figure><p>(:=)只是一种简化记法，让代码可读性更高。(:=)与 var 无区别。据经验，若声明初始值为零值的变量，应使用 var ；若声明初始值非零值的变量或者使用函数返回值创建变量，应该使用(:=)。</p><p>标识符首字母是小写的，代表不对外公开。反之首字母大写代表对外公开。不对外公开的标识符可通过间接的方式访问到。例如，通过函数返回一个未公开的值。</p><p>若map变量声明改为如下，会怎么样呢？</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> matchers = <span class="keyword">map</span>[<span class="keyword">string</span>]Matcher</span><br></pre></td></tr></table></figure><p>在使用matchers时会收到报错信息。这是因为map变量的默认零值是nil，所以要先通过make来构造map并将构造后的值赋值给变量。</p><h3 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h3><p>关键字func声明函数，结构是 func + 函数名 + 参数（可无） + 返回值（可无） + 函数体。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(searchTerm <span class="keyword">string</span>)</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="声明方法"><a href="#声明方法" class="headerlink" title="声明方法"></a>声明方法</h3><p>结构是 func + 接收者 + 函数名 + 参数 + 返回值 + 函数体。</p><p>实现接口方法时候需要注意case3，如果通过接口类型的值调用方法，使用指针作为接收者声明的方法，只能在接口类型的值是一个指针的时<br>候被调用 。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultMatcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="comment">// case 1</span></span><br><span class="line"><span class="comment">// 方法接收者为类型值的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 第一种声明类型值，第二种声明类型值的指针。都可以成功调用<span class="title">Search</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatch</span> 或 <span class="title">dm</span> := <span class="title">new</span><span class="params">(defaultMatch)</span></span></span><br><span class="line">dm.Search(feed, "test")</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 2</span></span><br><span class="line"><span class="comment">// 方法接收者为类型值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function">// 第一种声明类型值，第二种声明类型值的指针。都可以成功调用<span class="title">Search</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatch</span> 或 <span class="title">dm</span> := <span class="title">new</span><span class="params">(defaultMatch)</span></span></span><br><span class="line">dm.Search(feed, "test")</span><br><span class="line"></span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 3</span></span><br><span class="line"><span class="comment">// 方法接收者为类型值的指针，通过接口类型调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatch</span></span></span><br><span class="line"><span class="function">// 第一种接口类型的值为值，第二种接口类型的值为指针。只有第二种成功调用<span class="title">Search</span></span></span><br><span class="line"><span class="function">// 第一种报错 <span class="title">cannot</span> <span class="title">use</span> <span class="title">dm</span> <span class="params">(<span class="keyword">type</span> defaultMatcher)</span> <span class="title">as</span> <span class="title">type</span> <span class="title">Matcher</span> <span class="title">in</span> <span class="title">assignment</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">matcher</span> <span class="title">Matcher</span> = <span class="title">dm</span> 或 <span class="title">var</span> <span class="title">matcher</span> <span class="title">Matcher</span> = &amp;<span class="title">dm</span></span></span><br><span class="line">dm.Search(feed, "test")</span><br><span class="line"></span><br><span class="line"><span class="comment">// case 4</span></span><br><span class="line"><span class="comment">// 方法接收者为类型值，通过接口类型调用方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">dm</span> <span class="title">defaultMatch</span></span></span><br><span class="line"><span class="function">// 第一种接口类型的值为值，第二种接口类型的值为指针。都可以成功调用<span class="title">Search</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">matcher</span> <span class="title">Matcher</span> = <span class="title">dm</span> 或 <span class="title">var</span> <span class="title">matcher</span> <span class="title">Matcher</span> = &amp;<span class="title">dm</span></span></span><br><span class="line">dm.Search(feed, "test")</span><br></pre></td></tr></table></figure><h3 id="启动并同步操作goroutine"><a href="#启动并同步操作goroutine" class="headerlink" title="启动并同步操作goroutine"></a>启动并同步操作goroutine</h3><p>非常推荐使用 sync包中的WaitGroup 来跟踪 goroutine 的工作是否完成。WaitGroup 是一个计数信号量，我们可以利用它来统计所有的goroutine 是不是都完成了工作。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个无缓冲的通道，接收匹配后的结果</span></span><br><span class="line">results := <span class="built_in">make</span>(<span class="keyword">chan</span> *Result)</span><br><span class="line"><span class="keyword">var</span> waitGroup sync.WaitGroup</span><br><span class="line"><span class="comment">// len(feeds)的数量等于启动goroutine的数量</span></span><br><span class="line">waitGroup.Add(<span class="built_in">len</span>(feeds))</span><br></pre></td></tr></table></figure><p>goroutine完成工作后，会通过<code>waitGroup.Done()</code>递减waitGroup的计数值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为每个数据源启动一个 goroutine 来查找结果</span></span><br><span class="line"><span class="keyword">for</span> _, feed := <span class="keyword">range</span> feeds &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 启动一个 goroutine 来执行搜索</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(matcher Matcher, feed *Feed)</span></span> &#123;</span><br><span class="line">        Match(matcher, feed, searchTerm, results)</span><br><span class="line">        waitGroup.Done()</span><br><span class="line">&#125;(matcher, feed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动一个监控所有goroutine都完成工作的goroutine，利用WaitGroup的 Wait 方法。这个方法会导致 goroutine阻塞，直到 WaitGroup 内部的计数到达0。之后，goroutine 调用了内置的 close 函数，关闭了通道，最终导致程序终止。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    waitGroup.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="comment">// 通道会一直被阻塞，直到有结果写入</span></span><br><span class="line"><span class="comment">// 一旦通道被关闭，for 循环就会终止</span></span><br><span class="line"><span class="keyword">for</span> result := <span class="keyword">range</span> results &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%s:\n%s\n\n"</span>, result.Field, result.Content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用接口写通用的代码"><a href="#使用接口写通用的代码" class="headerlink" title="使用接口写通用的代码"></a>使用接口写通用的代码</h3><p>声明接口类型</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Matcher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Search(feed *Feed, searchTerm <span class="keyword">string</span>) ([]*Result, error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名接口的时候，需要遵守 Go 语言的命名惯例。如果接口类型只包含一个方法，类型的名字以 er 结尾。如果接口类型内部声明了多个方法，其名字需要与其行为关联。</p><p>实现接口</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> defaultMatcher <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m defaultMatcher)</span> <span class="title">Search</span><span class="params">(feed *Feed, searchTerm <span class="keyword">string</span>)</span> <span class="params">([]*Result, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下函数，可以接收实现了Macher接口的defaultMatcher类型作为传参。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Match</span><span class="params">(matcher Matcher, feed *Feed, searchTerm <span class="keyword">string</span>, results <span class="keyword">chan</span>&lt;- *Result)</span></span> &#123;</span><br><span class="line">searchResults, err := matcher.Search(feed, searchTerm)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理程序逻辑和错误"><a href="#处理程序逻辑和错误" class="headerlink" title="处理程序逻辑和错误"></a>处理程序逻辑和错误</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">document, err := m.retrieve(feed)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>每个代码文件都属于一个包，而包名应该与代码文件所在的文件夹同名。</li><li>Go 语言提供了多种声明和初始化变量的方式。如果变量的值没有显式初始化，编译器会将变量初始化为零值。</li><li>使用指针可以在函数间或者 goroutine 间共享数据。</li><li>通过启动 goroutine 和使用通道完成并发和同步。</li><li>Go 语言提供了内置函数来支持 Go 语言内部的数据结构。</li><li>使用 Go 接口可以编写通用的代码和框架。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公司项目中Makefile的使用</title>
      <link href="/2019/02/22/%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E4%B8%ADMakefile%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/02/22/%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E4%B8%ADMakefile%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Makefile基本格式"><a href="#Makefile基本格式" class="headerlink" title="Makefile基本格式"></a>Makefile基本格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><p>target - 目标文件</p></li><li><p>prerequisites - 生成target所需要的文件</p></li><li><p>command - 需要执行的命令（shell命令），命令必须以【tab】开头</p></li></ul><p><strong>Makefile的规则：</strong>prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</p><blockquote><p><strong>注意：</strong>JetBrains家的idea Tab键默认按出来是四个空格构成而不是制表符。</p><p><strong>设置方法：</strong>Preferences-》Code Style-〉Other File Types 中选择Use tab character 点击Ok。</p></blockquote><h2 id="伪目标-amp-PHONY"><a href="#伪目标-amp-PHONY" class="headerlink" title="伪目标&amp;.PHONY"></a>伪目标&amp;.PHONY</h2><p>如果taget文件不存在，那么他会执行后面所定义的命令。这里我们只讨论伪目标，伪目标不会像真正的目标（target）一样生成一个目标文件。通常情况下.PHONY会与伪目标一起配合使用，目的是为了避免和同名文件冲突、改善性能。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果编写一个规则，并不产生目标文件，则其命令在每次make 该目标时都执行。例如：</span><br><span class="line">clean:</span><br><span class="line">rm *.o temp</span><br><span class="line">因为&quot;rm&quot;命令并不产生&quot;clean&quot;文件，则每次执行&quot;make clean&quot;的时候，该命令都会执行。如果目录中出现了&quot;clean&quot;文件，则规则失效了：没有依赖文件，文件&quot;clean&quot;始终是最新的，命令永远不会 执行；为避免这个问题，可使用&quot;.PHONY&quot;指明该目标。如：</span><br><span class="line">.PHONY : clean</span><br><span class="line">这样执行&quot;make clean&quot;会无视&quot;clean&quot;文件存在与否。</span><br></pre></td></tr></table></figure><h2 id="go-fmt-…"><a href="#go-fmt-…" class="headerlink" title="go fmt ./…"></a>go fmt ./…</h2><p>go官方文档说明：./…代表在当前文件夹下和旗下所有子文件，除vendor目录下的文件。  </p><p>那么这个命令的意思就是格式化当前文件夹下和旗下所有子文件（除vendor目录下的文件）</p><h2 id="MakeFile如何忽略错误"><a href="#MakeFile如何忽略错误" class="headerlink" title="MakeFile如何忽略错误"></a>MakeFile如何忽略错误</h2><p>在可能出错的命令前面加上-</p><h2 id="如何一口气生成多个目标"><a href="#如何一口气生成多个目标" class="headerlink" title="如何一口气生成多个目标"></a>如何一口气生成多个目标</h2><p>Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它n个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那n个目标就总是不如“all”这个目标新。</p><h2 id="Makefile文件事例"><a href="#Makefile文件事例" class="headerlink" title="Makefile文件事例"></a>Makefile文件事例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: all format clean</span><br><span class="line"></span><br><span class="line">all: clean format build-dev package</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f main main.zip</span><br><span class="line"></span><br><span class="line">format:</span><br><span class="line">go fmt ./...</span><br><span class="line">-git clone https://github.com/golang/tools.git $(GOPATH)/src/golang.org/x/tools 2&gt;/dev/null</span><br><span class="line">go install golang.org/x/tools/cmd/goimports</span><br><span class="line">$(GOPATH)/bin/goimports -local=gitlab.oifitech.com -l -w `find . -type f -name &apos;*.go&apos; -not -path &apos;./vendor/*&apos;`</span><br><span class="line"></span><br><span class="line">build-dev:</span><br><span class="line">GOOS=linux go build -tags dev main.go</span><br><span class="line"></span><br><span class="line">build-prod:</span><br><span class="line">GOOS=linux go build -tags prod main.go</span><br><span class="line"></span><br><span class="line">package:</span><br><span class="line">go get -v github.com/aws/aws-lambda-go/cmd/build-lambda-zip</span><br><span class="line">$(GOPATH)/bin/build-lambda-zip main</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言实战-关于Go语言的介绍</title>
      <link href="/2019/02/14/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%85%B3%E4%BA%8EGo%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
      <url>/2019/02/14/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E6%88%98-%E5%85%B3%E4%BA%8EGo%E8%AF%AD%E8%A8%80%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Go语言能更高效的利用服务器上的核心；更快的编译速度；摒弃了继承，更多的使用组合。</p><h3 id="放弃继承，选择组合的原因"><a href="#放弃继承，选择组合的原因" class="headerlink" title="放弃继承，选择组合的原因"></a>放弃继承，选择组合的原因</h3><p>继承的缺点</p><ol><li>只能有一个父类不利于扩展。</li><li>会继承到不想拥有的功能。</li><li>不支持动态继承，运行时无法选择不同的父类。</li></ol><p>如何解决?</p><blockquote><p>引用荀子《劝学》中的一段话：</p><p>假舆马者，非利足也，而致千里；假舟楫者，非能水也，而绝江河。<br>君子生非异也，善假于物也。</p><p>所以说君子没有什么特殊的，就是善于使用工具罢了。这就是所谓的has-a。提倡用 has-a 去替代 is-a 。</p></blockquote><h2 id="Go解决了现在编程难题"><a href="#Go解决了现在编程难题" class="headerlink" title="Go解决了现在编程难题"></a>Go解决了现在编程难题</h2><p>为项目选择语言时，往往在 性能 和 快速开发 之间很难抉择。但GO语言不仅执行速度快，而且开发也快。</p><h2 id="GO语言关键特性"><a href="#GO语言关键特性" class="headerlink" title="GO语言关键特性"></a>GO语言关键特性</h2><ul><li>开发速度<ul><li>编译速度快。</li><li>运行前编译器会检查类型错误。</li></ul></li><li>并发（更高效的利用多核，占用资源远少于线程。）<ul><li>goroutine对并发的支持。</li><li>通道，让 goroutine 之间数据通信。</li></ul></li><li>Go 语言的类型系统（提供了灵活的、无继承的类型系统。）<ul><li>用组合设计模式。</li><li>独特的接口实现机制，允许用户对行为进行建模。</li></ul></li><li>内存管理<ul><li>Go 语言把内存管理交给编译器去做。</li></ul></li></ul><h2 id="Go-Playground"><a href="#Go-Playground" class="headerlink" title="Go Playground"></a>Go Playground</h2><p>给他人演示某个想法时，Go Playground 是非常好的方式，因为它提供在线编译和分享功能。<br><strong>地址：</strong><a href="http://play.golang.org" target="_blank" rel="noopener">http://play.golang.org</a></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>Go 语言是快速的，带有一个强大的标准库。</li><li>Go 语言内置对并发的支持。</li><li>Go 语言使用接口作为代码复用的基础模块。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go实战 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
